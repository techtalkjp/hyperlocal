# Hyperlocal Web アプリケーション UI/UX 改善作業指示書

## 作業の背景

Hyperlocal Web アプリケーションは、デザインポリシーに定められた「操作がブロックされない」「操作に対してすぐにフィードバックがある」「すぐに元の状態に戻れる」「操作の予測可能性」という4つの原則を実現するため、段階的な改善を実施する。本作業指示書では、5つの主要な改善項目を4つのフェーズに分けて実施する計画を示す。

## フェーズ1: スクロール位置の保持機能の実装

このフェーズでは、ユーザーが店舗リストから詳細ページに遷移し、戻った際に同じスクロール位置に復帰できる機能を実装する。

### 作業1-1: ScrollRestoration の getKey 設定

apps/web/app/root.tsx の ScrollRestoration コンポーネントに getKey プロップを追加する。React Router の標準機能を活用し、シンプルで確実な実装を実現する。

getKey プロップには、location.pathname と location.search を組み合わせた文字列を返す関数を設定する。これにより、同じ URL パス（検索パラメータを含む）には同じキーが割り当てられ、スクロール位置が自動的に保存・復元される。

この実装により、詳細ページから "Back to List" ボタンで戻った際、React Router が同じキーのページと認識し、保存されていたスクロール位置を自動的に復元する。カスタムフックや sessionStorage の手動管理は不要となり、React Router のネイティブな機能だけで実装できる。

getKey 関数の実装は以下の通りとする。location オブジェクトを受け取り、pathname と search を連結した文字列を返す。検索パラメータを含めることで、同じパスでも異なるフィルター条件のリストページごとに独立したスクロール位置を管理できる。

### 作業1-2: 動作検証とテスト

実装完了後、pnpm validate コマンドを実行し、すべての品質チェック（format、lint、typecheck、test）が成功することを確認する。

次に、実際の動作を確認する。店舗リストページを下の方までスクロールし、店舗をクリックして詳細ページに遷移する。詳細ページの "Back to List" ボタンで戻った時、元のスクロール位置に復帰することを確認する。

異なるカテゴリーやランキングタイプのリストページで、それぞれ独立したスクロール位置が保存されることを確認する。ブラウザの戻るボタンでも同様に機能することを確認する。

複数のブラウザ（Chrome、Safari、Firefox）とデバイス（PC、タブレット、スマートフォン）で動作を確認する。特にモバイル環境では、スクロール位置の復元がスムーズに行われることを重点的にテストする。

## フェーズ2: エラーハンドリングの強化

このフェーズでは、ネットワークエラーやサーバーエラーが発生した際に、ユーザーに適切なメッセージと回復手段を提供する機能を実装する。

### 作業2-1: エラー分類ユーティリティの作成

apps/web/app/features/error/utils.ts ファイルを作成し、エラーの種類を判定する関数を実装する。

classifyError 関数は、Error オブジェクトまたは Response オブジェクトを受け取り、エラーの種類を返す。ステータスコードが404の場合は "not-found"、500番台の場合は "server-error"、ネットワーク例外の場合は "network-error" を返す。

isNetworkError 関数は、エラーオブジェクトが TypeError かつ message に "fetch" または "network" が含まれる場合に true を返す。これにより、ネットワーク接続の問題を識別できる。

getErrorMessage 関数は、エラーの種類と現在の言語設定に基づいて、適切なエラーメッセージを返す。メッセージは多言語対応とし、各言語ごとに分かりやすい説明文を用意する。

### 作業2-2: エラーメッセージコンポーネントの作成

apps/web/app/features/error/components ディレクトリに、エラー種類ごとのメッセージコンポーネントを作成する。

NetworkErrorMessage コンポーネントは、ネットワーク接続の問題を説明し、インターネット接続を確認するよう促す。再試行ボタンを表示し、クリックすると現在のページを再読み込みする。

ServerErrorMessage コンポーネントは、サーバー側の一時的な問題を説明し、しばらく待ってから再試行するよう促す。同様に再試行ボタンを提供する。

NotFoundMessage コンポーネントは、リクエストされたページが存在しないことを説明し、トップページへのリンクを提供する。関連するエリアやカテゴリーへのリンクも表示し、ユーザーが次の行動を取りやすくする。

各コンポーネントは、shadcn/ui の Alert コンポーネントをベースに構築する。アイコンと色を使用して、エラーの重要度を視覚的に示す。ネットワークエラーは黄色、サーバーエラーは赤色、Not Found は青色のアラートとする。

### 作業2-3: エラーバウンダリーの実装

apps/web/app/components/error-boundary.tsx ファイルを作成し、React Router のエラーバウンダリーを実装する。

このコンポーネントは、useRouteError フックでエラーオブジェクトを取得し、classifyError 関数でエラーの種類を判定する。種類に応じて適切なメッセージコンポーネントを表示する。

再試行機能は、useRevalidator フックを使用して実装する。再試行ボタンがクリックされたら、revalidator.revalidate() を呼び出し、現在のルートのローダーを再実行する。

再試行ボタンは、クリック後3秒間無効化する。これにより、連続クリックによるサーバーへの過度なリクエストを防止する。無効化中はボタンにローディングスピナーを表示し、処理中であることを示す。

開発環境では、エラーの詳細情報を折りたたみ可能な形で表示する。本番環境では詳細情報は非表示とし、ユーザーフレンドリーなメッセージのみを表示する。

### 作業2-4: 各ルートへのエラーバウンダリー適用

主要なルートファイルに、ErrorBoundary をエクスポートする。

apps/web/app/routes/_public.($lang)+/area.$area.$category.$rank/route.tsx、apps/web/app/routes/_public.($lang)+/place.$place/route.tsx など、ユーザーが頻繁にアクセスするページに優先的に適用する。

各ルートで ErrorBoundary コンポーネントをエクスポートすることで、そのルート内で発生したエラーを捕捉できる。エラーバウンダリーは、作成した共通のエラーバウンダリーコンポーネントを使用する。

### 作業2-5: 多言語対応とテスト

apps/web/app/features/error/i18n.ts ファイルを作成し、エラーメッセージの翻訳データを定義する。

英語、日本語、韓国語、中国語（簡体字・繁体字）の5言語に対応する。各言語で、ユーザーにとって分かりやすく、次のアクションが明確な文章を用意する。

実装完了後、以下のシナリオでテストを実施する。ネットワークを切断した状態でページにアクセスし、ネットワークエラーメッセージが表示されることを確認する。API サーバーを停止した状態でアクセスし、サーバーエラーメッセージが表示されることを確認する。存在しない URL にアクセスし、Not Found メッセージが表示されることを確認する。

各エラーメッセージから再試行ボタンをクリックし、適切にページが再読み込みされることを確認する。すべての言語でエラーメッセージが正しく表示されることを確認する。

## フェーズ3: ローディング状態の統一とナビゲーション改善

このフェーズでは、ローディング状態の視覚的フィードバックを統一し、ナビゲーション要素を改善する。

### 作業3-1: Skeleton UI コンポーネントの作成

apps/web/app/components/ui/skeleton.tsx ファイルを作成し、基本的な Skeleton コンポーネントを実装する。

Skeleton コンポーネントは、グレーの背景色で矩形領域を表示する。アニメーションとして、左から右へのグラデーションをゆっくりと流す。アニメーションは控えめにし、注意を散漫にしないよう配慮する。

LocalizedPlaceCardSkeleton コンポーネントを作成する。このコンポーネントは、実際の店舗カードと同じレイアウトを持ち、画像エリア、タイトルエリア、評価エリア、説明エリアをプレースホルダーで示す。

各エリアのサイズは、実際のコンテンツの平均的なサイズに合わせる。これにより、Skeleton からコンテンツへの切り替え時のレイアウトシフトを最小限に抑える。

### 作業3-2: リストページへの Skeleton UI 適用

apps/web/app/routes/_public.($lang)+/area.$area.$category.$rank/route.tsx を修正し、データ読み込み中に Skeleton を表示する。

useNavigation フックで navigation.state を取得し、"loading" の場合は LocalizedPlaceCardSkeleton を複数個表示する。表示する個数は5個とし、一画面に収まる程度の数にする。

navigation.state が "idle" になったら、実際の店舗カードを表示する。切り替え時にフェードインアニメーションを適用し、滑らかな遷移を実現する。

Skeleton の最小表示時間を300ミリ秒に設定する。これにより、データ読み込みが極端に速い場合でも、Skeleton がチラつかないようにする。最小表示時間の制御には、useState と useEffect を組み合わせて実装する。

### 作業3-3: パンくずリストの常時表示対応

apps/web/app/routes/_public.($lang)+/place.$place/route.tsx のローダーを拡張し、店舗が属するエリアとカテゴリーを取得する。

クエリパラメータから area と category が取得できない場合、PlaceListing テーブルから店舗の所属情報を検索する。複数のエリアに属している場合は、店舗の位置座標から最も近いエリアを選択する。複数のカテゴリーに属している場合は、最初にマッチしたカテゴリーを選択する。

パンくずリストのコンポーネントを修正し、area と category が必ず存在する前提で実装する。パンくずリストには、ホーム、エリア名、カテゴリー名、店舗名の階層を表示する。

"Back to List" ボタンのデザインを変更する。variant を "ghost" から "outline" に変更し、視認性を高める。ボタンの位置は現在のままとするが、パンくずリストとの距離を調整し、視覚的なグループ化を明確にする。

### 作業3-4: ローディングインジケーターの統一

既存の LoaderIcon の使用箇所を確認し、一貫したデザインに統一する。

スピナーのサイズは、コンテキストに応じて sm、md、lg の3種類を用意する。ボタン内では sm、リストアイテムでは md、ページ全体のローディングでは lg を使用する。

スピナーの色は、現在のテーマカラーに合わせて blue-500 に統一する。アニメーション速度は animate-spin クラスを使用し、すべて同じ速度にする。

PageLoadingProgress コンポーネントは引き続き使用するが、色とアニメーション速度を他のローディングインジケーターと統一する。

### 作業3-5: 動作確認とパフォーマンステスト

実装完了後、以下の確認を実施する。

リストページでカテゴリーやランキングを切り替えた際、Skeleton UI が表示されることを確認する。Skeleton からコンテンツへの切り替えがスムーズで、レイアウトシフトが発生しないことを確認する。

店舗詳細ページに直接アクセスした際、パンくずリストが正しく表示されることを確認する。リストページから遷移した場合と、直接アクセスした場合で、パンくずリストの内容が適切であることを確認する。

ローディングインジケーターのデザインが統一されていることを、各画面で確認する。ページ読み込み時間を計測し、Skeleton UI の追加によるパフォーマンスへの影響がないことを確認する。

## フェーズ4: キャンセル機能の追加と最終調整

このフェーズでは、位置情報取得のキャンセル機能を追加し、全体的な仕上げを行う。

### 作業4-1: AbortController 対応の実装

apps/web/app/routes/resources+/nearby-areas/route.tsx の clientLoader を拡張し、AbortSignal を受け取れるようにする。

位置情報取得のリクエストにタイムアウト処理を追加する。10秒以内に位置情報が取得できない場合は、自動的にキャンセルしてエラーを返す。

AbortSignal が abort された場合、位置情報取得を中断し、エラーではなく null を返す。これにより、ユーザーが自らキャンセルした操作をエラーとして扱わないようにする。

### 作業4-2: キャンセルボタンの追加

NearbyAreasSelector コンポーネントに、AbortController のインスタンスを保持する state を追加する。

ドロップダウンを開いた時点で、新しい AbortController インスタンスを生成する。fetcher.load() を呼び出す際、このインスタンスの signal を渡す方法を検討するが、React Router の fetcher.load() は AbortSignal を直接サポートしていないため、代替案として Promise.race() を使用する。

ローディング中の表示を変更し、LoaderIcon の横に小さなキャンセルボタンを追加する。ボタンは "Cancel" というラベルと、X アイコンを表示する。

キャンセルボタンがクリックされたら、AbortController の abort() メソッドを呼び出し、fetcher の状態をリセットする。ドロップダウンは開いたままとし、ユーザーが再度試行できるようにする。

### 作業4-3: キャンセル後の状態管理

キャンセル実行後、ドロップダウンメニューの表示を初期状態に戻す。エラーメッセージは表示せず、通常のボタン表示に戻る。

ユーザーが再度ドロップダウンを開いた場合、新しい AbortController インスタンスを生成し、再度位置情報取得を試みる。前回のキャンセル履歴は保持せず、毎回新しいリクエストとして扱う。

複数回キャンセルと再試行を繰り返した場合でも、正常に動作することを確認する。メモリリークが発生しないよう、古い AbortController インスタンスは適切に破棄する。

### 作業4-4: 全体的な最終調整

すべての改善が実装された後、アプリケーション全体を通しで確認する。

デザインポリシーの4つの原則に照らし、各機能が適切に動作することを確認する。操作がブロックされていないか、フィードバックは即座に表示されるか、元の状態に戻れるか、操作が予測可能かを検証する。

各ブラウザとデバイスで動作確認を実施する。特にモバイル環境での動作を重点的にテストする。

パフォーマンス計測を実施し、改善前後での読み込み時間、インタラクション速度、スクロール性能を比較する。改善によってパフォーマンスが劣化していないことを確認する。

### 作業4-5: ドキュメントの更新

実装した改善内容を、プロジェクトのドキュメントに反映する。

CLAUDE.md に、新しく追加したコンポーネントの説明を追加する。エラーハンドリングのパターンや、Skeleton UI の使用方針を記載する。

今後の開発者が同じパターンを踏襲できるよう、実装例とベストプラクティスを示す。特に、ScrollRestoration の getKey 設定によるスクロール位置の保持とエラーハンドリングは、他のページでも適用すべき重要なパターンであることを明記する。

## 作業スケジュールと成果物

各フェーズは、前のフェーズの完了後に開始する。各フェーズの終了時に pnpm validate による品質チェックと動作確認を実施し、問題がなければ次のフェーズに進む。

フェーズ1は、スクロール位置保持の実装とテストで完了する。成果物として、getKey が設定された ScrollRestoration コンポーネントを含む root.tsx が提供される。これにより、アプリケーション全体でスクロール位置が適切に管理される。

フェーズ2は、エラーハンドリングの実装とテストで完了する。成果物として、エラーバウンダリーコンポーネント、エラーメッセージコンポーネント、多言語対応の翻訳データが提供される。

フェーズ3は、Skeleton UI とナビゲーション改善の実装とテストで完了する。成果物として、Skeleton コンポーネント、改善されたパンくずリスト、統一されたローディングインジケーターが提供される。

フェーズ4は、キャンセル機能の実装、最終調整、ドキュメント更新で完了する。成果物として、キャンセル機能付きの近隣エリア検索と、更新されたプロジェクトドキュメントが提供される。

すべてのフェーズ完了後、デザインポリシーに沿った使いやすい Web アプリケーションが実現される。ユーザーは操作を妨げられることなく、即座のフィードバックを受け取り、いつでも元の状態に戻ることができ、予測可能な操作体験を得られる。
