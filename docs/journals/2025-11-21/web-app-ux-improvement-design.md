# Hyperlocal Web アプリケーション UI/UX 改善設計

## 設計の目的

UI/UX 評価レポートで指摘された課題に対する具体的な実装設計を示す。この設計は、デザインポリシーの4つの原則を徹底し、ユーザーにとって使いやすいアプリケーションを実現することを目指す。

## 改善の優先順位

改善は以下の優先順位で実施する。優先度は、ユーザー体験への影響度と実装の複雑さを考慮して決定した。

最優先として、スクロール位置の保持に取り組む。これはユーザーが最も頻繁に遭遇する問題であり、改善効果が大きい。次に、エラーハンドリングの強化を実施する。エラー発生時の体験は、アプリケーション全体の印象を大きく左右するためである。その後、ローディング状態の統一、ナビゲーションの改善、キャンセル機能の追加へと進める。

## スクロール位置の保持

### 解決すべき課題

現在、店舗リストページから店舗詳細ページに遷移し、"Back to List" で戻った際、リストの先頭に戻ってしまう。ユーザーはリストを下の方まで見て店舗を選んだのに、戻った時に同じ位置に戻れないと、どこまで見たかを見失ってしまう。

### 設計方針

React Router の標準的な ScrollRestoration は、ブラウザの履歴に基づいてスクロール位置を復元する。しかし、アプリケーション内のリンク遷移では、より細かい制御が必要になる。

スクロール位置の保存には sessionStorage を使用する。ページ遷移時にスクロール位置を保存し、戻った際に復元する。保存するキーには、現在の URL パスと検索パラメータを含めることで、異なるリストページごとに独立したスクロール位置を管理できる。

### 実装設計

新しいカスタムフックとして useScrollRestoration を作成する。このフックは apps/web/app/hooks/use-scroll-restoration.ts に配置する。

フックは以下の責務を持つ。コンポーネントがマウントされた時、sessionStorage から現在の URL に対応するスクロール位置を取得し、復元する。コンポーネントがアンマウントされる直前、現在のスクロール位置を sessionStorage に保存する。店舗詳細ページへの遷移が発生した時、その時点のスクロール位置を保存する。

useEffect の使用は、スクロール位置というブラウザの DOM 状態との同期という外部リソースとの連携であるため、useEffect Policy に沿った使用となる。

area.$area.$category.$rank/route.tsx で、リストを表示するコンポーネントにこのフックを適用する。フックは URL の変更を監視し、同じページに戻ってきた場合はスクロール位置を復元し、新しいページに遷移した場合は新しいスクロール位置として記録する。

店舗詳細ページの LocalizedPlaceCard コンポーネントでは、リンクのクリック時に現在のスクロール位置を保存するイベントハンドラーを追加する。これにより、詳細ページへ遷移する直前の位置を確実に記録できる。

セッションストレージに保存するデータ構造は、URL パスをキーとし、スクロール位置の Y 座標を値とする。キーには検索パラメータも含めることで、同じパスでも異なるフィルター条件の場合は別のスクロール位置として管理する。

復元のタイミングは、コンポーネントのマウント後、データの読み込みが完了してから実行する。データがまだ読み込まれていない状態でスクロール位置を復元しても、正しい位置に戻れないためである。React Router の loader からのデータ取得完了を待ってから復元処理を実行する。

### 実装上の注意点

スクロール位置の復元は、非同期的に実行する必要がある。ブラウザのレンダリングが完了する前にスクロール処理を実行すると、意図した位置に戻らない場合がある。requestAnimationFrame を使用してレンダリング後に復元処理を実行する。

また、セッションストレージの容量制限に配慮し、古いスクロール位置データは定期的にクリーンアップする。保存するスクロール位置の数を制限し、最新のものだけを保持する方針とする。

## エラーハンドリングの強化

### 解決すべき課題

現在、ネットワークエラーやサーバーエラーが発生した場合、ユーザーに何が起こったのか、どうすれば良いのかが明確に伝わらない。エラー画面が表示されても、回復手段が提示されていない。

### 設計方針

React Router v7 のエラーバウンダリー機能を活用し、エラーの種類に応じた適切なメッセージと回復手段を提供する。エラーは大きく分けて、ネットワークエラー、サーバーエラー、データ不在エラーの3種類に分類する。

ネットワークエラーは、インターネット接続の問題や API サーバーへの到達失敗を示す。この場合、ユーザーに接続状態を確認するよう促し、再試行ボタンを提供する。

サーバーエラーは、API サーバー側の問題を示す。この場合、一時的な問題である可能性が高いことを伝え、時間をおいて再試行するよう促す。

データ不在エラーは、リクエストされたリソースが存在しないことを示す。この場合、トップページや関連するページへの導線を提供する。

### 実装設計

apps/web/app/components/error-boundary.tsx に、新しいエラーバウンダリーコンポーネントを作成する。このコンポーネントは、React Router の ErrorBoundary コンポーネントを拡張する。

エラーの種類を判定するユーティリティ関数を作成する。Response オブジェクトのステータスコードや、エラーオブジェクトの内容から、エラーの種類を分類する。404 エラーはデータ不在、500 番台エラーはサーバーエラー、ネットワーク例外はネットワークエラーとして扱う。

各エラー種類に対応したコンポーネントを用意する。NetworkErrorMessage、ServerErrorMessage、NotFoundMessage の3つである。これらのコンポーネントは、エラーの内容を分かりやすく説明し、次に取るべきアクションを明示する。

再試行機能は、React Router の useRevalidator フックを使用して実装する。再試行ボタンがクリックされたら、現在のルートのローダーを再実行し、データを再取得する。

エラーメッセージは多言語対応とする。現在の言語設定に応じて、適切な言語でメッセージを表示する。エラーメッセージの翻訳データは、apps/web/app/features/error/i18n.ts に配置する。

### 実装上の注意点

エラーバウンダリーは、各ルートレベルで設定する。すべてのエラーをトップレベルで捕捉するのではなく、各ページごとに適切なエラーハンドリングを実装する。これにより、エラーが発生してもアプリケーション全体が停止せず、影響範囲を限定できる。

再試行ボタンは、連続クリックを防ぐため、クリック後は一定時間無効化する。これにより、サーバーへの過度なリクエストを防止する。

エラーの詳細情報は、開発環境では表示するが、本番環境では非表示とする。セキュリティ上の理由から、内部的なエラー詳細をユーザーに見せるべきではない。

## ローディング状態の統一

### 解決すべき課題

現在、一部の画面ではローディングインジケーターが表示されるが、すべての非同期処理に対して一貫したフィードバックが提供されていない。ローディング状態の表示方法がバラバラで、統一感に欠ける。

### 設計方針

すべての非同期操作に対して、一貫したローディングフィードバックを提供する。ローディング状態は、処理の性質に応じて適切な UI パターンを選択する。

ページ全体のローディングには、既存の PageLoadingProgress を使用する。これは画面上部にプログレスバーを表示し、ページ遷移中であることを示す。

コンテンツの読み込みには、Skeleton UI を使用する。これにより、レイアウトシフトを防ぎつつ、どのようなコンテンツが表示されるかの予測を与える。

ボタンのクリックなどのアクション実行中は、ボタン内にスピナーを表示し、ボタンを無効化する。これにより、処理中であることが明確に伝わり、重複実行を防止できる。

### 実装設計

Skeleton UI コンポーネントを apps/web/app/components/ui/skeleton.tsx に作成する。このコンポーネントは、店舗カード、リストアイテム、詳細ページなど、各コンテンツタイプに応じた Skeleton を提供する。

店舗リストページでは、データ読み込み中に LocalizedPlaceCardSkeleton を表示する。この Skeleton は、実際の店舗カードと同じレイアウトを持ち、画像、タイトル、評価などの領域をグレーのプレースホルダーで示す。

React Router の useNavigation フックを使用して、ナビゲーション中の状態を取得する。状態が "loading" の場合は Skeleton を表示し、"idle" になったら実際のコンテンツを表示する。

既存の LoaderIcon の使用箇所を見直し、一貫したスピナーコンポーネントを使用するよう統一する。スピナーの色、サイズ、アニメーション速度を統一し、どの箇所でも同じ視覚的フィードバックを提供する。

### 実装上の注意点

Skeleton UI は、実際のコンテンツとできるだけ同じレイアウトを持つべきである。レイアウトが大きく異なると、コンテンツが表示された瞬間にレイアウトシフトが発生し、逆にユーザー体験を損なう。

Skeleton の表示時間が短すぎる場合、チラつきの原因となる。最小表示時間を設定し、一定時間以上表示されるようにすることで、滑らかな体験を提供する。

アニメーションの使用は控えめにする。Skeleton のアニメーションが派手すぎると、注意が散漫になる。シンプルなフェードインアニメーションや、左から右へのグラデーションなど、控えめな表現にとどめる。

## ナビゲーションの改善

### 解決すべき課題

店舗詳細ページに直接アクセスした場合、リストページへの戻る導線が明確でない。パンくずリストは実装されているが、リストページから遷移した場合のみ表示される。

### 設計方針

店舗詳細ページでは、遷移元に関わらず、常に明確なナビゲーション要素を提供する。パンくずリストを常時表示し、エリアページやカテゴリーページへの導線を明示する。

現在のパンくずリストは、URL のクエリパラメータから遷移元の情報を取得している。直接アクセスの場合は、店舗が属するエリアとカテゴリーから、適切なパンくずリストを生成する。

### 実装設計

place.$place/route.tsx のローダーで、店舗が属するエリアとカテゴリーを取得する。PlaceListing テーブルから、その店舗がどのエリアとカテゴリーに属しているかを検索する。

複数のエリアやカテゴリーに属している場合は、最も代表的なものを選択する。代表的なエリアは、店舗の位置座標から最も近いエリアとする。代表的なカテゴリーは、店舗のジャンル情報から最も関連性の高いカテゴリーとする。

パンくずリストのコンポーネントを拡張し、クエリパラメータがない場合でもパンくずリストを表示できるようにする。パンくずリストには、ホーム、エリア、カテゴリー、店舗名の階層を表示する。

"Back to List" ボタンは、より目立つデザインに変更する。現在の ghost バリアントではなく、outline バリアントを使用し、視認性を高める。ボタンの位置も、ページ上部の目立つ位置に配置する。

### 実装上の注意点

パンくずリストの生成にデータベースクエリを追加すると、ページの読み込み速度に影響する。この追加クエリは、メインの店舗情報取得クエリと並行して実行し、パフォーマンスへの影響を最小限に抑える。

店舗が複数のエリアやカテゴリーに属している場合、すべての選択肢をユーザーに提示するのも一案である。ドロップダウンメニューで他のエリア・カテゴリーの組み合わせを選択できるようにすることで、ユーザーに柔軟性を提供できる。

## キャンセル機能の追加

### 解決すべき課題

近隣エリア検索で位置情報の取得を開始すると、完了またはエラーまで待つしかない。位置情報の取得に時間がかかる場合や、ユーザーが途中でやめたくなった場合に、明示的なキャンセル手段がない。

### 設計方針

位置情報取得中に、キャンセルボタンを表示する。キャンセルがクリックされたら、位置情報の取得を中断し、ドロップダウンを閉じるか、初期状態に戻る。

AbortController を使用して、位置情報取得のリクエストをキャンセル可能にする。これにより、進行中の非同期処理を適切に中断できる。

### 実装設計

nearby-areas/route.tsx の clientLoader を拡張し、AbortController を受け取れるようにする。位置情報取得のリクエストに、AbortSignal を渡す。

NearbyAreasSelector コンポーネントに、キャンセル用の state を追加する。AbortController のインスタンスを保持し、キャンセルボタンがクリックされたら abort メソッドを呼び出す。

ドロップダウンメニュー内のローディング表示を変更し、ローディングインジケーターの横にキャンセルボタンを追加する。ボタンは小さく控えめなデザインとし、"Cancel" というラベルを付ける。

キャンセルが実行されたら、fetcher の状態をリセットし、エラーメッセージを表示せずに初期状態に戻る。ユーザーが自らキャンセルした操作は、エラーとして扱うべきではない。

### 実装上の注意点

位置情報取得の API は、AbortSignal を直接サポートしていない場合がある。この場合、タイムアウト処理と組み合わせて、擬似的なキャンセル機能を実装する。

キャンセルボタンは、ローディング中のみ表示する。通常時や完了時には表示せず、UI をシンプルに保つ。

キャンセル後、ユーザーが再度近隣エリア検索を試みた場合、新しい AbortController インスタンスを生成する。古いインスタンスを再利用すると、正しく動作しない。

## 実装の進め方

これらの改善は、段階的に実装する。まず、スクロール位置の保持から着手する。これは単独で完結しており、他の機能への依存がない。

次に、エラーハンドリングの強化を実施する。エラーバウンダリーの実装は、アプリケーション全体に影響するため、十分なテストが必要である。

ローディング状態の統一は、既存のコンポーネントを段階的に置き換えていく。一度にすべてを変更するのではなく、ページごとに Skeleton UI を導入していく。

ナビゲーションの改善とキャンセル機能の追加は、最後に実施する。これらは比較的影響範囲が限定的であり、他の改善が完了した後でも問題ない。

各改善の実装後、必ず実機でのテストを行う。特に、スクロール位置の復元は、環境によって動作が異なる場合があるため、複数のブラウザとデバイスで確認する。

## まとめ

この設計に基づいて実装を進めることで、デザインポリシーで掲げた原則を徹底できる。スクロール位置の保持により、ユーザーは安心して詳細ページに遷移できる。エラーハンドリングの強化により、問題が発生しても適切に対処できる。ローディング状態の統一により、一貫した体験を提供できる。ナビゲーションの改善により、どこからでも目的の場所に戻れる。キャンセル機能の追加により、操作の自由度が高まる。

これらの改善を通じて、Hyperlocal の Web アプリケーションは、ユーザーにとってより使いやすく、信頼できるものとなる。
